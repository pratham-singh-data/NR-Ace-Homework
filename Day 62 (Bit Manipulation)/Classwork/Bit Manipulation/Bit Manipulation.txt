Bit manipulation is very important for optimisation, eg: Say we need to check if a number is even or not:
1) We can use modulo to see if remainder is 0 (Even) or not.
2) Observe:
    0 => 0000
    1 => 0001
    2 => 0010
    3 => 0011
    4 => 0100
    5 => 0101
    6 => 0110
    7 => 0111

    Notice how all evens have 0 on LSB and all odds have 1, so in order to check we can do:
    return inp & 1;

    1 => 0001
    all data except LSB is converted to 1 and if last bit is 0, we get False (0000) and if not we get True (0001)

    Bitwise operations are always faster than arithmatic operations hence this is better.

Basic Operations:
A   B   A&B A|B A^B
0   0   0   0   0
0   1   0   1   1
1   0   0   1   1
1   1   1   1   0

Shift Operators:
    Consider the data: 3 (00000011; in 8 bit)

    1) Right Shift (>>): Moves aall bits one place to the right (empty spaces aare always filled with 0 so;) Result hence is: 00000001 (This is 1); 3 >> 1

    2) Left Shift (<<): Moves aall bits one place to the right (empty spaces aare always filled with 0 so;) Result hence is: 00000110 (This is 6); 3 << 1

Calculate 3 << 2
    00001100
    This is 12

Calculate 43 << 3, 43 << 2, 43 >> 1, 43 >> 2, 43 >> 3 (Don't think with 8 bits, no digit should be truncated)
    43: 101011

1) 43 << 3
    101011000
    433

2) 43 << 2
    10101100
    172

3) 43 >> 1
    10101
    21

4) 43 >> 2
    1010
    10

5) 43 >> 3
    101
    5

Any given number can be represented as: b(n) b(n-1) b(n-2) ... b1 b0
and the number is b0*pow(2,0) + b1*pow(2,1) + b2*pow(2,2) + ... + bn*pow(2,n)

Now if we left shift this it becomes b0*pow(2,1) + b1*pow(2,2) + b2*pow(2,3) + ... + bn*pow(2,n + 1)
or 2 * (b0*pow(2,0) + b1*pow(2,1) + b2*pow(2,2) + ... + bn*pow(2,n))
so x << 1 => 2 * x

and x << 2 => (x << 1) << 1
so x * 2 * 2 == x * 4

generally; x << y => pow(2, y) * x

also x >> 1 => pow(2, -1) * x
x >> 2 => pow(2, -2) * x
x >> y => pow(2, -y) * x
(Actual number is gotten by truncating the fractional part, in case of integers)

Q) How to check if i bit of a number is set or not.
=> Use a mask with only i th bit beiing set:
    eg for bit 5: 000100000

    To get this mask: 1 << i where i is the bit position to check.

    if(x & (1 << i) == 0)
        bit at i is not set
    else
        bit at i is set

Q) Set x's ith bit
=> (return x | (1 << i))

Q) Unset the ith bit
=> return x & !(1 << i)